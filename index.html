<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3 en Línea</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }

        header {
            background-color: #4CAF50;
            padding: 20px;
            text-align: center;
            color: white;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            padding: 20px;
        }

        .section {
            background-color: #fff;
            margin: 20px;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            flex: 1;
            min-width: 300px;
        }

        .integrantes {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h2 {
            text-align: center;
            color: #4CAF50;
        }

        p {
            text-align: justify;
        }

        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #333;
        }
        code {
            background-color: #eee;
            padding: 2px 4px;
            border-radius: 4px;
        }
        pre {
            background-color: #eee;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        #codigoModal {
            display: none; /* Oculto por defecto */
            position: fixed;
            z-index: 1; /* En la parte superior */
            left: 0;
            top: 0;
            width: 100%; /* Ancho completo */
            height: 100%; /* Alto completo */
            overflow: auto; /* Habilita el desplazamiento si es necesario */
            background-color: rgba(0,0,0,0.5); /* Fondo negro con opacidad */
        }
        .modal-content {
            background-color: #fff;
            margin: 15% auto; /* 15% desde la parte superior y centrado */
            padding: 20px;
            border: 1px solid #888;
            width: 80%; /* Ancho del modal */
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close:hover,
        .close:focus {
            color: rgb(0, 0, 0);
            text-decoration: none;
            cursor: pointer;
        }

    </style>
</head>
<body>

<header>
    <h1>3 en Línea  (^(x.o)^)</h1>
</header>

<div class="container">
    <div class="section">
        <h2>Integrantes del Equipo</h2>
        <div class="integrantes">
            <img src="img/diego.jpeg" width="150" height="200" alt="Integrante 1">
            <p>Diego Lozano Camargo (230110530)</p>
            <img src="img/fuentes.JPG" width="150" height="250" alt="Integrante 2">
            <p>Bryan Fuentes Perez (230110581)</p>

            <h1>Prueba de ejecucion</h1>
    
                <iframe width="560" height="315" src="https://www.youtube.com/embed/wC2sS7xGsyE?si=OeBwfAXb5Sk22azu" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                <h1>Diagrama de clases UML</h1>
                <img src="img/e.jpeg" width="400" height="500" alt="Integrante 1">

                <h1>Ver Código completo</h1>
<button id="mostrarCodigo">Mostrar Código</button>

<div id="codigoModal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h2>Código Python</h2>
        <pre><code>
import tkinter as tk
from tkinter import messagebox

class Gato:
    def __init__(self, root):
        self.root = root
        self.root.title("3 EN RAYA")
        self.matriz = [[None for _ in range(3)] for _ in range(3)]
        self.turno = "X"
        self.crear_botones()

    def crear_botones(self):
        for i in range(3):
            for j in range(3):
                boton = tk.Button(self.root, text='', width=5, height=2,
                                  command=lambda i=i, j=j: self.cambiar_valor(i, j))
                boton.grid(row=i, column=j)
                self.matriz[i][j] = boton

    def cambiar_valor(self, i, j):
        if self.matriz[i][j]['text'] == '':
            self.matriz[i][j]['text'] = self.turno
            if self.verificar_ganador():
                messagebox.showinfo("¡Ganaste!", f"El jugador {self.turno} ha ganado!")
                self.resetear()
            elif self.tablero_lleno():
                messagebox.showinfo("Empate", "El juego ha terminado en empate.")
                self.resetear()
            else:
                self.turno = 'O' if self.turno == 'X' else 'X'

    def verificar_ganador(self):
        combinaciones = [
            [(0, 0), (0, 1), (0, 2)],
            [(1, 0), (1, 1), (1, 2)],
            [(2, 0), (2, 1), (2, 2)],
            [(0, 0), (1, 0), (2, 0)],
            [(0, 1), (1, 1), (2, 1)],
            [(0, 2), (1, 2), (2, 2)],
            [(0, 0), (1, 1), (2, 2)],
            [(0, 2), (1, 1), (2, 0)]
        ]
        for combinacion in combinaciones:
            if self.matriz[combinacion[0][0]][combinacion[0][1]]['text'] == self.turno and \
               self.matriz[combinacion[1][0]][combinacion[1][1]]['text'] == self.turno and \
               self.matriz[combinacion[2][0]][combinacion[2][1]]['text'] == self.turno:
                return True
        return False

    def tablero_lleno(self):
        for fila in self.matriz:
            for boton in fila:
                if boton['text'] == '':
                    return False
        return True

    def resetear(self):
        for fila in self.matriz:
            for boton in fila:
                boton['text'] = ''
        self.turno = "X"
        </code></pre>
    </div>
</div>

<script>
    // Obtener el modal
    var modal = document.getElementById("codigoModal");

    // Obtener el botón que abre el modal
    var btn = document.getElementById("mostrarCodigo");

    // Obtener el elemento <span> que cierra el modal
    var span = document.getElementsByClassName("close")[0];

    // Cuando el usuario hace clic en el botón, abrir el modal 
    btn.onclick = function() {
        modal.style.display = "block";
    }

    // Cuando el usuario hace clic en <span> (x), cerrar el modal
    span.onclick = function() {
        modal.style.display = "none";
    }

    // Cuando el usuario hace clic en cualquier parte fuera del modal, cerrarlo
    window.onclick = function(event) {
        if (event.target == modal) {
            modal.style.display = "none";
        }
    }
</script>

                
        </div>
    </div>

    <div class="section">
        <h2>Implementación</h2>
        <img src="img/Tic_tac_toe.svg" width="500" height="500" alt="Implementación del Juego">
<h2>Descripción General</h2>
<p>El juego "3 en Raya" es una implementación gráfica de un clásico juego de mesa para dos jugadores. Los jugadores alternan turnos para marcar sus símbolos (X y O) en un tablero de 3x3. El objetivo es alinear tres de sus símbolos en una fila, columna o diagonal. La aplicación está construida utilizando la biblioteca Tkinter de Python, que proporciona herramientas para crear interfaces gráficas de usuario (GUI).</p>

<h2>Clases y Métodos</h2>

<h3>Clase <code>gato</code></h3>
<p>Esta clase representa el juego en sí. Contiene la lógica del juego, la interfaz gráfica y el manejo de eventos.</p>

<h4>Método <code> void __init__(self, tk root)</code></h4>
<ul>
    <li><strong>Descripción:</strong> Constructor de la clase. Inicializa la ventana principal del juego y establece el estado inicial del tablero y el turno del jugador.</li>
    <li><strong>Tipo de retorno:</strong> <code>None</code> (similar a <code>void</code>).</li>
    <li><strong>Tipos de datos utilizados:</strong>
        <ul>
            <li><code>root</code>: <code>tk.Tk</code> (objeto de la ventana principal).</li>
            <li><code>matriz</code>: <code>list</code> de <code>list</code> (matriz 3x3 que contiene objetos <code>Button</code>).</li>
            <li><code>turno</code>: <code>str</code> (indica el símbolo del jugador actual, "X" o "O").</li>
        </ul>
    </li>
</ul>

<h4>Método <code>void crear_botones(self)</code></h4>
<ul>
    <li><strong>Descripción:</strong> Crea una cuadrícula de botones que representan cada celda del tablero. Cada botón está vinculado a un comando que permite al jugador marcar su símbolo en la celda correspondiente.</li>
    <li><strong>Tipo de retorno:</strong> <code>None</code> (similar a <code>void</code>).</li>
    <li><strong>Tipos de datos utilizados:</strong>
        <ul>
            <li><code>i</code>, <code>j</code>: <code>int</code> (índices de fila y columna para la matriz).</li>
            <li><code>boton</code>: <code>tk.Button</code> (objeto botón creado para la celda).</li>
        </ul>
    </li>
</ul>

<h4>Método <code>void cambiar_valor(self, i, j)</code></h4>
<ul>
    <li><strong>Descripción:</strong> Cambia el valor del botón en la posición (i, j) con el símbolo del jugador actual. Verifica si hay un ganador o si el tablero está lleno después de cada movimiento.</li>
    <li><strong>Tipo de retorno:</strong> <code>None</code> (similar a <code>void</code>).</li>
    <li><strong>Tipos de datos utilizados:</strong>
        <ul>
            <li><code>i</code>, <code>j</code>: <code>int</code> (índices de fila y columna para la matriz).</li>
        </ul>
    </li>
</ul>

<h4>Método <code>bool verificar_ganador(self)</code></h4>
<ul>
    <li><strong>Descripción:</strong> Comprueba todas las combinaciones posibles para determinar si el jugador actual ha ganado. Retorna <code>True</code> si hay un ganador y <code>False</code> en caso contrario.</li>
    <li><strong>Tipo de retorno:</strong> <code>bool</code>.</li>
    <li><strong>Tipos de datos utilizados:</strong>
        <ul>
            <li><code>combinaciones</code>: <code>list</code> de <code>list</code> (lista de combinaciones ganadoras).</li>
            <li><code>combinacion</code>: <code>tuple</code> (cada combinación a verificar).</li>
        </ul>
    </li>
</ul>

<h4>Método <code>bool tablero_lleno(self)</code></h4>
<ul> 
    <li><strong>Descripción:</strong> Verifica si todas las celdas del tablero están ocupadas. Retorna <code>True</code> si el tablero está lleno y <code>False</code> si hay al menos una celda vacía.</li>
    <li><strong>Tipo de retorno:</strong> <code>bool</code>.</li>
    <li><strong>Tipos de datos utilizados:</strong>
        <ul>
            <li><code>fila</code>: <code>list</code> (cada fila de la matriz).</li>
            <li><code>boton</code>: <code>tk.Button</code> (cada botón en la fila).</li>
        </ul>
    </li>
</ul>

<h4>Método <code>void resetear(self)</code></h4>
<ul>
    <li><strong>Descripción:</strong> Reinicia el juego limpiando todos los botones y restableciendo el turno al jugador inicial.</li>
    <li><strong>Tipo de retorno:</strong> <code>None</code> (similar a <code>void</code>).</li>
    <li><strong>Tipos de datos utilizados:</strong>
        <ul>
            <li><code>fila</code>: <code>list</code> (cada fila de la matriz).</li>
            <li><code>boton</code>: <code>tk.Button</code> (cada botón en la fila).</li>
        </ul>
    </li>
</ul>

<h2>Funcionamiento del Juego</h2>
<ol>
    <li>Al iniciar la aplicación, se crea una ventana con un tablero de 3x3, donde cada celda está representada por un botón.</li>
    <li>Los jugadores alternan turnos haciendo clic en las celdas vacías.</li>
    <li>Después de cada movimiento, el juego verifica si un jugador ha ganado o si el juego ha terminado en empate.</li>
    <li>Si hay un ganador o el juego termina en empate, se muestra un mensaje y el tablero se reinicia para jugar de nuevo.</li>
</ol>

<h2>Consideraciones</h2>
<ul>
    <li>La lógica del juego asegura que no se puedan realizar movimientos en celdas ya ocupadas.</li>
    <li>El uso de <code>messagebox</code> permite mostrar información relevante al jugador de manera amigable.</li>
    <li>El diseño del juego es simple y accesible, lo que lo hace adecuado para jugadores de todas las edades.</li>
</ul>
</p>
    </div>
</div>

</body>
</html>
